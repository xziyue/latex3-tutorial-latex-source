% !BIB TS-program = bibtex
% !TeX TS-program = xelatex
\documentclass{ltugboat}

\input{preamble.tex}

\title{Modern \LaTeX~programming: an example based \liii~tutorial}
\author{Ziyue Xiang}
\address{Purdue University}
\netaddress{ziyue.alan.xiang (at) gmail (dot) com}
\personalURL{https://www.alanshawn.com}
\ORCID{0000-0001-6054-5801}


\ExportExamplesfalse

\begin{document}

\begin{abstract}
The programming side of \LaTeX\ is often overlooked.
In many cases, the use of programming capabilities of \LaTeX\ can facilitate document editing and improve the quality of the compiled document.
\LaTeX3 is a set of modern programming interfaces provided by the \LaTeX\ kernel.
Compared to traditional \LaTeX\ programming, \LaTeX3 yields more standardized, readable, and robust code.
In this tutorial, we present a series of examples that help readers understand the commonly used modules of \LaTeX3.
\end{abstract}

\maketitle

\tableofcontents
\ListOfCodeExample


\section{Introduction}

There is no doubt that \LaTeX~is viewed as a typesetting language by most of the users.
The programming aspect of \LaTeX~is often overlooked by many.
In practice, many large and structured documents can benefit from the programming capabilities provided by \LaTeX. 
Even understanding the most basic programming principles in \LaTeX~can greatly facilitate the efficiency of generating figures or tables that are made up of similar and repeated sub-structures.
The infrastructure provided by \LaTeXe\ \cite{berry2017latex} is already Turing complete, which means its programming capabilities are identical to those of Python \cite{vanrossum2010python} and C \cite{ritchie1988c}.
However, the syntax and conventions of \LaTeXe~are nonstandardized and obsolete compared to the mainstream programming languages now.
This makes learning \LaTeXe~programming more difficult for today's \LaTeX~users.

%Many people view \LaTeX\ as a typesetting language and overlook the importance of programming in document generation process. 
%In reality, many large and structural documents can benefit from
%a programming backend, which enhances layout standardization, symbol
%coherence, editing speed and many other aspects. Despite the fact the
%standard \LaTeX\ (\LaTeXe) is already Turing complete, which means
%it is capable of solving any programming task, the design of numerous
%programming interfaces is highly inconsistent due to the long history
%of \LaTeX. This makes programming with \LaTeXe\ extremely daunting, 
%even for seasoned computer programmers.

In order to modernize the programming interfaces in \LaTeX, the \liii~programming interfaces are introduced \cite{mittelbach2020quo}.
Unfortunately, the learning materials for this tool chain is scarce.
One of the few resources available for new learners is The \liii\ Interfaces \cite{l3interface}, which is an technical documentation that is difficult to for one to start with.
Therefore, in this material we intend to provide an example based \liii~tutorial for \liii~learners with sufficient background in computer programming.
That is, the reader is expected to understand basic structures (e.g., loops, conditional branches) as well as data types (e.g., integers, floating point numbers, strings) in programs. 
It would be helpful if the reader also understands the basic principles of the C programming language \cite{ritchie1988c}.

%To make programming in \LaTeX\ easier, the \liii\ programming interface
%is introduced, which aims to provide modern-programming-language-like
%syntax and library for \LaTeX\ programmers. Unfortunately, learning
%materials for this wonderful language is scarce. 
%which is essentially an API documentation that is not designed for 
%introductory purposes. This situation may have barred many \LaTeX\ 
%users from utilizing the generic programming capabilities of \LaTeX.
%Therefore, this article intends to provide an easy-to-understand 
%tutorial for \LaTeX\ users with computer programming knowledge.
%Hopefully, readers can improve their \LaTeX\ editing efficiency and 
%document quality after understanding \liii.


Since the \liii~project has accumulated a huge code base over the years, it is infeasible to cover all of its functionalities in one tutorial.
In this tutorial, we focus on the most frequently used components in \liii. 
The complete documentation of \liii\  can be found in \cite{l3interface}. 
In the upcoming section titles, if parentheses are present, then the content in the parentheses is the corresponding section number in \cite{l3interface}.

\subsection{Motivations of \liii}

As mentioned above, \LaTeXe~is already Turing complete and serves as the building blocks of many existing packages. In this section, we describe the problems of traditional \LaTeX~programming, which justifies the reason why \liii~is developed despite already having the powerful \LaTeXe~and many other existing packages.

\paragraph{Nonuniform interface} 

Outside \liii, the interfaces provided by traditional \LaTeX~are not standardized. They suffer from the following disadvantages.

% 1: function/variable naming
% 2: overlapping/scattered packages
% 3: numerical computations

Firstly, the mechanism of \LaTeX~can affect the readability of traditional \LaTeX~code. 
In \LaTeX, functions and variables are all declared using control sequences (see Chapter 3 of \cite{knuth1984texbook}).
When a function is invoked, it is expected to execute a series of predefined procedures. Variables are used to store values only.
In \LaTeX, we can declare functions that absorb one or multiple arguments.
Sometimes arguments are stored in variables.
Since both functions and its arguments can be both control sequences, it is difficult to distinguish between them. 
This is likely to make reading traditional \LaTeX\ source code difficult.
%Unlike many other programming languages that enclose the arguments with parentheses, \LaTeX~does not require delimiters between the function and its arguments. 
%In the example below, we define 6 control sequences, where \inltex|\ta| and \inltex|\td| are functions, and the rest are variables.
%\begin{latexsample*}[ex:func-var-def]
%\newcommand{\ta}[2]{[arg1={#1}, arg2={#2}]}
%\newcommand{\tb}{$\alpha$}
%\newcommand{\tc}{$\beta$}
%\newcommand{\td}[1]{[arg3={#1}]}
%\newcommand{\te}{$\gamma$}
%\newcommand{\tf}{$\delta$}
%\ta\tb\tc\td\te\tf
%\end{latexsample*}
%\noindent On line \lref{ex:func-var-def}{7}\footnotemark, we call functions \inltex|\ta| and \inltex|\td| with their respective arguments (stored in variables), as well as output the value of \inltex|\tf|.
%In appearance, line 7 is six control sequences placed next to each other.
%It is very difficult to understand the code unless the programmer finds out which control sequences are functions and how many arguments each function uses.
%This makes the source code of some \LaTeXe\ packages challenging to read.

%\footnotetext{Every listing has a unique index, which is shown at the bottom right corner. A line in the listing is referenced by <listing index>:<line number>.}

Secondly, in traditional \LaTeX~the implementation of many fundamental programming capabilities are provided by external packages.
%As a result, the functionalities of multiple packages may overlap. 
For example, to compare the equality of two strings, we can use \inltex|\ifthenelse| and \inltex|\equal| from \verb|ifthen| package \cite{pkg:ifthen};
we can use \inltex|\pdfstrcmp| from \verb|pdftexcmds| package \cite{pkg:pdftexcmds};
we can also use \inltex|\IfStrEq| from \verb|xstring| package \cite{pkg:xstring}. 
The use of multiple similar packages is likely to cause redundancy and compatibility issues.
The lack of a centralized documentation and comparison for these similar packages also increases the learning cost of traditional \LaTeX\ programming.
%Therefore, \liii\ is to provide a set of unified and standardized interfaces for all possible \LaTeX\ variable types.

\paragraph{Expansion control} 

% two situations: when trying to store something in a variable
% when passing arguments to a function
% only concerns arguments

Unlike generic programming languages, \LaTeX\ does not have support for types.
Programming components such as variables, functions and function arguments are all treated in the same way.
Therefore, \LaTeX~programmers need to more precisely control how variables are defined and how functions are called. 
These techniques are known as expansion control. 
Expansion control in traditional \LaTeX~is achieved by using the \inltex|\expandafter| command, which is difficult to use because the number of \inltex|\expandafter| command calls required may scale exponentially \cite{bechtolsheim1988tutorial}.

\liii~aims at mitigating these inconveniences in traditional \LaTeX\ programming.
It provides a uniform interface for \LaTeX~programmers, where functions and variables are separated from each other. 
It defines standardized infrastructure for many programming tasks such as string processing, numerical calculation, regular expression matching, etc.
The new expansion control mechanism of \liii\ is easier and more straightforward to use.

%Expansion control is mostly required in two  scenarios. 
%Firstly, it is needed when one is defining variables. 
%Suppose we are trying to generate a random integer and save it in the variable \inltex|\myrandint|, as shown in the example below. 
%To generate a random integer, we can use the function \inltex|\int_rand:nn|. 
%This is a \liii\ function that contains a colon (:) in its function name. 
%We will describe the function naming rules in \liii\ later. 
%For now, we just need to know \inltex|\int_rand:nn| takes two arguments, which are the lower bound and upper bound of the random integer, respectively. 
%In line \lref{ex:gen-save-rand-int}{4}, we wish to save the generated random integer in \inltex|\myrandint|. 
%In line \lref{ex:gen-save-rand-int}{6}[8], we output the random integer stored in the variable three times. 
%It can be seen that the value stored in \inltex|\myrandint| changes every time, which is undesirable. 
%If we use the \inltex|\meaning| command to examine the definition of \inltex|\myrandint|, we can see that \inltex|\myrandint| contains the \inltex|\int_rand:nn| command call instead of the generated random number.
%\begin{latexsample*}[ex:gen-save-rand-int]
%\ExplSyntaxOn % enter LaTeX3 mode
%% set the random seed for reproducibility
%\sys_gset_rand_seed:n {0}
%\newcommand{\myrandint}{\int_rand:nn {1}{100}}
%\ExplSyntaxOff % exit LaTeX3 mode
%\par the random number is: \myrandint
%\par the random number is: \myrandint
%\par the random number is: \myrandint
%\par \meaning\myrandint
%\end{latexsample*}
%
%Fundamentally, \TeX\ works by doing: commands are substituted by their definition,
%which is subsequently replaced by definition's definition, until 
%something irreplaceable is reached (e.g. text or \TeX\ primitives). 
%This process is called \emph{expansion}. The mechanism of expansion
%may sound simple and straightforward. However, it usually requires
%a lot of manual fine-tuning in practice.
%
%Consider the example below. We know that the \inltex|\uppercase| macro
%capitalize English letters, which renders the first output line in all 
%caps. But if we store some text in \inltex|\myname| and then apply
%\inltex|\uppercase| to the command, we can see that the output is
%\emph{not} turned into uppercase letters.
%
%\begin{latexsample*}
%\par\uppercase{Alan Xiang}
%\newcommand*{\myname}{Alan Xiang}
%\par\uppercase{\myname}
%\end{latexsample*}
%
%Why would this happen? Let us dig into how \inltex|\uppercase| works. 
%The \inltex|\uppercase| macro scans each token\footnotemark inside its argument 
%group one by one. If an English letter is encountered, its uppercase 
%form is left in the output stream. If a command is encountered, it 
%will not try to apply \inltex|\uppercase| to the content of the command. 
%Instead, the command itself will be placed into the output stream. 
%In this case, \inltex|\myname| will be left untouched in the output, 
%which is subsequently expanded to its original definition.

%(More details about tokens can be found in and Chapter 7 of \cite{knuth1984texbook})
%
%\footnotetext{Tokens are smallest units that \TeX\ compilers work 
%with. For now, we can consider a token to be either a character 
%or command. For more about \TeX\ tokens, see \cite{overleaf-token}.}
%
%What if we also want to capitalize the content of \inltex|\myname| as 
%well? To achieve this, we need to fine-tune the expansion process by 
%changing the \emph{order} of expansion. That is, to expand 
%\inltex|\myname| before \inltex|\uppercase|. In this way, the 
%\inltex|\uppercase| command will receive the content of 
%\inltex|\myname| in the form of English letters, which allows 
%capitalization to function correctly.
%
%In \LaTeX, the classic way of controlling the order of expansion is
%via the \inltex|\expandafter| macro, which it is notoriously
%difficult to use. According to \emph{A Tutorial on \cs{expandafter}} 
%\cite{bechtolsheim1988tutorial}, to reverse the expansion of a series
%of $n$ tokens, the $i$th token has to be preceded by $2^{n-i}-1$
%\inltex|\expandafter|s. The exponential growth of the number of 
%\inltex|\expandafter|s greatly reduces the readability of source code
%and increases the chances of mistakes. 
%For example, in Joseph Wright's answer to an expansion-related
%question on \TeX\ StackExchange \cite{tex-se-expanding}, a total of 26 
%\inltex|\expandafter|s are used to reorder the expansion of merely 4
%arguments.  To avoid this annoyance, one of the key features
%of \liii\ is to provide simple and reliable expansion control.
%
%
%
%\paragraph{Modernized experience} \TeX\ was first designed in the late 1970s, when
%computer hardware and programming languages were prototypes compared to
%their contemporary counterparts. As a result, \TeX\ and \LaTeX\ contain
%quirky usages that may seem odd for programmers today. For example, to
%multiply a counter variable by 3, one writes 
%\inltex|\multiply|\inltex|\counter| \inltex|by| \inltex|3|; to invoke the \verb|date| command via
%the terminal, one writes \inltex|\immediate\write18{date}|. 
%It can be seen that these syntaxes are either outdated or perplexing. 
%In a fairly popular language nowadays 
%(e.g. Python), these two tasks can be done by \inlpy|counter*=3|
%and \inlpy|os.system('date')|, whose code possesses superior
%simplicity and interpretability. \liii\ attempts to modernize 
%the \LaTeX\ language by adapting to modern-language-like syntaxes
%and introducing a naming system that makes \LaTeX\ code more
%readable.

\subsection{Compiling Examples}

This tutorial is based on examples.
To compile the examples, the minimum preamble required is:
\begin{latexsample**}[ex:min-preamble]
\documentclass{article}
\usepackage{tikz} % load TikZ for some TikZ examples
\usepackage{expl3} % load latex3 packages
\end{latexsample**}
\noindent The example code should be placed between \inltex|\begin{document}| 
and \inltex|\end{document}|. 
All examples were tested with \TeX Live  2020 on Ubuntu 20.04.
For newer versions of \LaTeX~compilers, there is no need to load the \verb|expl3| package explicitly (i.e., Line \lref{ex:min-preamble}{3}\footnotemark~is optional).

\footnotetext{Every listing has a unique index, which is shown at the bottom right corner. A line in the listing is referenced by <listing index>:<line number>.}

The source code of this tutorial can be obtained from \url{https://github.com/xziyue/latex3-tutorial-latex-source}.


\section{\liii\ Naming Conventions (I-1)}

Unlike many programming languages that enclose the function arguments with parentheses, \LaTeX\ does not require delimiters between the function and its arguments. 
In the example below, we define 6 control sequences, where \inltex|\ta| and \inltex|\td| are functions, and the rest are variables.
\begin{latexsample*}[ex:func-var-def]
\newcommand{\ta}[2]{[arg1={#1}, arg2={#2}]}
\newcommand{\tb}{$\alpha$}
\newcommand{\tc}{$\beta$}
\newcommand{\td}[1]{[arg3={#1}]}
\newcommand{\te}{$\gamma$}
\newcommand{\tf}{$\delta$}
\ta\tb\tc\td\te\tf
\end{latexsample*}
\noindent On Line \lref{ex:func-var-def}{7}, we call functions \inltex|\ta| and \inltex|\td| with their respective arguments (stored in variables). 
We output the value of \inltex|\tf| next.
In appearance, Line \lref{ex:func-var-def}{7} is six control sequences placed next to each other.
It is difficult to understand the code unless the programmer finds out which control sequences are functions and how many arguments each function absorbs.
To improve readability, \liii\ introduces a special naming convention where functions and variables are clearly distinguishable. In addition, programmers can gather more information from function and variable names such as the number of function arguments, the type of variables, and the scope of variables. 

%In Python or C++, if we see \inlpy|a(b);|, we can 
%tell \inlpy|a| is a function and \inlpy|b| is its 
%argument. However, in \LaTeX, if we see \inltex|\a\b|, 
%there are be two possibilities:
%\begin{itemize}
%\item \inltex|\a| is a function and \inltex|\b| is its argument
%\item Both \inltex|\a| and \inltex|\b| are variables
%\end{itemize}
%The syntactic design of \LaTeX\ makes it difficult
%to distinguish between functions and variables, for
%each control sequence can either be a function that 
%receives arguments or a variable that absorbs nothing.
%It can lead to confusion when one is trying to understand
%others' source code. Therefore, \liii\ introduces a set
%of naming rules that encode important information into
%the name of control sequences as a way to improve 
%readability.

%Before discussing \liii\ naming conventions, let us take a diversion 
%to look at the low-level design of \LaTeX\ and find out 
%how we can use non-English characters in command names.



\subsection{Category Codes and Command Names}

In \LaTeX, every input character can be classified into 16 categories. 
Each category is identified with an integer ranging from 0 to 15, which is known as the \emph{category code}.
More detail about category codes can be obtained from \cite{overleaf-catcode}.
We focus on one of the sixteen categories, which is known as \emph{letter}.
In most cases, command names in \LaTeX\ can only be made up of characters from the letter category.
Because the letter category only contains the lowercase and uppercase versions of the 26 English alphabets by default, command names are comprised of these 52 characters exclusively under the initial \LaTeX\ setup.
By extending the letter category, it is possible to add more permissible characters to command names.
For example, the \inltex|\makeatletter| command changes the category of \texttt{@} to letter, which allows it to be used in command names \cite{texse:makeatletter}. 
Many packages use \inltex|\makeatletter| and include the \texttt{@} character in the defined command names. 
This technique can prevent \LaTeX\ users from overwriting a command imported from the package accidentally, since one can only access commands whose names are made up of English alphabets under the default settings.
To separate \liii\ from other \LaTeX\ programming conventions, \liii\ introduces two new characters into the command names, namely \texttt{\_} (underscore) and \texttt{:} (semicolon).


%In \LaTeX, every input character is associated with a \emph{category code} \cite{overleaf-catcode}. 

%When the \LaTeX\ compiler reads a source file, it will read
%and process each character one by one. For each character in 
%the file, in addition to its character code, \LaTeX\ compiler 
%will also assign a \emph{category code} based on current
%category code table. The default \LaTeX\ category code table
%is shown in Table \ref{table:catcode-table}.
%
%\begin{center}
%\small
%\tabletail{\hline}
%\tablehead{
%\hline
%\makecell{Category\\Code} & Description & 
%\makecell{Character(s)}\\ \hline
%}
%\bottomcaption{Default \LaTeX\ category code table \cite{overleaf-catcode}. 
%Characters surround by single quotes indicate their C-style
%representation.}
%\label{table:catcode-table}
%\begin{supertabular}{|c|>{\centering}m{0.4\linewidth}|c|}
%0 & Escape character: tells \LaTeX\ 
%to start looking for a command & \verb|\| \\  \hline
%1 & Start of group & \verb|{|\\ \hline
%2 & End of group & \verb|}|\\ \hline
%3 & Toggle math mode & \verb|$|\\ \hline
%4 & Alignment tab & \verb|&|\\ \hline
%5 & End of line & \verb|'\r'|\\ \hline
%6 & Macro parameter & \verb|#| \\ \hline
%7 & Superscript & \verb|^| \\ \hline
%8 & Subscript & \verb|_| \\ \hline
%9 & Ignored character & \verb|'\0'| \\ \hline
%10 & Spacer & \verb|'\32'|, \verb|'\t'|\\ \hline
%11 & Letter & \verb|A|--\verb|Z|, \verb|a|--\verb|z|, \ldots\\ \hline
%12 & Other & \verb|0|--\verb|9|, \verb|+|, \verb|@|\ldots \\ \hline
%13 & Active character: used for single character commands & 
%\verb|~|\ldots\\ \hline
%14 & Comment character: ignore everything that follows until 
%end of line & \verb|%|\\ \hline
%15 & Invalid character: not allowed in \verb|.tex| files & 
%\verb|'\127'|\ldots \\ \hline
%\end{supertabular}
%\end{center}
%
%\LaTeX\ reacts to each character according to its category code
%instead of character code. If we change the category code associated
%with a character, we can completely change the \emph{meaning} of that
%character. For example, if we assign category code 7 to \verb|_| and
%category code 8 to \verb|^|, we can use \verb|_| to denote superscript
%and \verb|^| to denote subscript.
%
%\begin{latexsample}{Doing 123}
%\ExplSyntaxOn
%\tl_set:Nn \l_tmpa_tl {A}
%\group_begin:
%\tl_set:Nn \l_tmpa_tl {B}
%\par value~inside~group:~\tl_use:N \l_tmpa_tl
%\group_end:
%\par value~outside~group:~\tl_use:N \l_tmpa_tl
%
%\tl_set:Nn \l_tmpb_tl {A}
%\group_begin:
%\tl_gset:Nn \l_tmpb_tl {B}
%\par value~inside~group:~\tl_use:N \l_tmpb_tl
%\group_end:
%\par value~outside~group:~\tl_use:N \l_tmpb_tl
%\ExplSyntaxOff
%\end{latexsample}


\bibliographystyle{tugboat}
\bibliography{main.bib}

\makesignature

\end{document}