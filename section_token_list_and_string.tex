\section{Token List and String}

A token list is a sequence of tokens, which can be used to store data in \LaTeX{}.
It is very easy to create a token list: simply enclose the data with braces \inlpl|{...}|, and a token list is formed.
A string in \LTT{} is a special type of token list that contains only string tokens.
In this section, we show examples of creating, manipulating, and using token lists and strings.

In \cref{ex:tl-ops}, token lists are used as a container to store and access data.
In the example, we build a simple student management system that allows one to obtain student names by their IDs.
We also define a function that outputs all students stored.
\begin{latexsample}[exampletitle={Token List Operations},examplelabel={ex:tl-ops}]
  % declare functions in LaTeX3 mode
  \ExplSyntaxOn
  % create a token list to access student by index
  \tl_new:N \l_student_db_tl
  % create a token list to store all students
  \tl_new:N \l_student_all_tl
  \newcommand{\AddStudent}[1]
  {
    % append data to the token list
    \tl_put_right:Nn \l_student_db_tl {{#1}}
    \tl_if_empty:NTF \l_student_all_tl 
    {
      \tl_put_right:Nn \l_student_all_tl {#1}
    }
    {
      \tl_put_right:Nn \l_student_all_tl {,~#1}
    }
  }
  \newcommand{\GetStudentName}[1]
  {
    % get data by index
    \tl_item:Nn \l_student_db_tl {#1}
  }
  \newcommand{\GetAllStudentName}
  {
    % output the token list
    \tl_use:N \l_student_all_tl
  }
  \ExplSyntaxOff

  % use functions in normal mode
  \AddStudent{Alice}
  \AddStudent{Bob}
  \par\GetStudentName{1}
  \par\GetStudentName{2}
  \par\GetAllStudentName
  \AddStudent{Mary}
  \AddStudent{John}
  \par\GetAllStudentName
\end{latexsample}

In \cref{ex:tl-ops}, we store each student name twice in \inltex|\l_student_db_tl| and \inltex|\l_student_all_tl|. 
\inltex|\l_student_db_tl| allows index access for student names.
\inltex|\l_student_all_tl| stores the name of all students, joined by commas, which is used by \inltex|\GetAllStudentName|. 
Every time \inltex|\AddStudent| is called, the new student name will be inserted into the two token lists.
When inserting into \inltex|\l_student_all_tl|, there is no need to prepend comma for the first name.
This behavior can be achieved by using the condition statement \inltex|\tl_if_empty:NTF|, where the first argument is the token list variable, the second argument is the code to execute if the token list is empty, and the third argument is the code to execute if the token list is not empty.
Notice that the student name is surrounded with curly braces when inserting into \inltex|\l_student_db_tl|, which effectively encapsulates each student name inside a group. 
When calling \inltex|\tl_item:Nn|, the entire group will be returned, which allows one to retrieve the entire student name.


Strings are a special type of token lists that contain only string tokens.
\begin{latexsample}[exampletitle={Difference Between Token List and String},examplelabel={ex:diff-tl-string}]
\ExplSyntaxOn
\tl_new:N \l_my_a_tl
\tl_new:N \l_my_b_tl
\tl_set:Nn \l_my_a_tl {Hello, \LaTeX!}
\str_set:Nn \l_my_b_tl {Hello, \LaTeX!}
\par\tl_use:N \l_my_a_tl
\par\tl_use:N \l_my_b_tl
\ExplSyntaxOff
\end{latexsample}
In \cref{ex:diff-tl-string}, we created two token list variables \inltex|\l_my_a_tl| and \inltex|\l_my_b_tl|, and assigned the same content to them.
The difference is that values are assigned to \inltex|\l_my_a_tl| using token list assignment function \inltex|\tl_set:Nn|, while values are assigned to \inltex|\l_my_b_tl| using string assignment function \inltex|\str_set:Nn|.
In the output, it can be seen that the comnand \inltex|\LaTeX{}| is expanded in \inltex|\l_my_a_tl|, but not expanded in \inltex|\l_my_b_tl|.
This shows that the string assignment function will attempt to keep the content as is without any further processing.
\textbf{However, because of implementation details of \LaTeX{}, the values assignment to string variables may not be exactly the same as input.}
For example, one can notice there is an extra space between X and ! in the output of \inltex|\l_my_b_tl|.

In \LaTeX{}, extra care is needed when comparing token lists.
For token lists to be equal, not only the character codes of each token need to be the same, but also the category codes of each token need to be the same.
\begin{latexsample}[exampletitle={Comparison of Token Lists},examplelabel={ex:token-list-comparison}]
\def\testVar{_}
\ExplSyntaxOn
\tl_new:N \l_my_test_tl
\tl_set:Nn \l_my_test_tl {_}
\par\tl_if_eq:NNTF \l_my_test_tl \testVar {Same} {Diff}
\par\str_if_eq:NNTF \l_my_test_tl \testVar {Same} {Diff}
\ExplSyntaxOff
\end{latexsample}
In \cref{ex:token-list-comparison}, we created two token lists: \inltex|\testVar| and \inltex|\l_my_test_tl|, both containing the underscore character.
However, because \inltex|\testVar| is created in normal \LaTeX{} mode and \inltex|\l_my_test_tl| is created in \LTT{} mode, the category codes of the underscore character in the two token lists are different.
When comparing the two token lists using token list comparison functions \inltex|\tl_if_eq:|, the two token lists are not the same. 
That is because \inltex|\tl_if_eq:| functions compare both character codes and category codes of each token.
When comparing the two token lists using string comparison functions \inltex|\str_if_eq:|, the two token lists are the same due to the fact that \inltex|\str_if_eq:| functions only compare the character codes of each token.

In \cref{ex:text-in-squares}, we use \inlpl|map| functions to iterate through each character in a string and output each character inside a square box.
\begin{latexsample}[exampletitle={Create Text in Squares},examplelabel={ex:text-in-squares}]
\ExplSyntaxOn
\tl_new:N \l_my_tmpa_str
\cs_new:Npn \my_square_text:n #1
{
  % get the length of the string
  \str_set:Nn \l_my_tmpa_str {#1}
  \str_map_inline:Nn \l_my_tmpa_str
  {
    % output each character in a square box
    \fbox{\makebox[1.5em][c]{\rule{0em}{1.5em} ##1}}
  }
}
\par\my_square_text:n {Hello}
\par\my_square_text:n {It's~Me!}
\ExplSyntaxOff
\end{latexsample}
